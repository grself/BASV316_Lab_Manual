# Visualizing Frequency

```{r 070.01, include = FALSE}

# Load some libraries
library(knitr)
library(kableExtra) # For building pretty tables
library(here)

# Set the rproj home directory
here::here()

# Set some knitr options
options(knitr.table.format = "html")
knitr::opts_chunk$set(
  collapse = TRUE,
  strip.white = TRUE,
  comment = "#>",
  out.width = "65%",
  message=FALSE,
  warnings=FALSE
)

# Turn on the DataCamp Light interactive tools
tutorial::go_interactive()

```

## Introduction

Categorical data items are often reported using frequency tables where the number of times a particular survey item was selected is displayed. However, there are many ways to visualize frequency data and people using the plots introduced in this tutorial often find it easier to understand the underlying data than with a table.

-----

## Bar Plot

A bar plot is used to display the frequency count for categorical data. The following figure is a bar plot showing the number of automobiles with three, four, and five gears according to the [mtcars] data frame.

```{r 070.02, fig.width=3.5,fig.height=4,out.width="40%", fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

barplot(table(mtcars$gear), 
        main = "Count by Gears",
        xlab = "Number of Gears",
        ylab = "Number of Cars",
        col = rainbow(6)
        )

```

These types of visuals are more effective than a table full of numbers and they are easy to generate with _R_.

### Demonstration: Bar Plot

The following script creates a simple bar plot. _Note: this is one long R command that has been broken up over several lines to make it easier to understand._

* Line 2: This creates a bar plot using the `barplot` function. The first argument sent to the function is the data source for the heights of each bar in the plot. In this case, _R_ creates a table from the _gears_ variable in [mtcars] and then uses that table as data input for the plot. All of the other lines in this script embellish the bar plot to make it more usable.
* Line 3: The “main” attribute sets the main title for the bar plot. In general, for any graphic in _R_ _main_ is used to set the title of the graph.
* Line 4: This creates the label for the x-axis. 
* Line 5: This creates the label for the y-axis.
* Line 6: This sets the color palette for the graph. In this case, the _rainbow_ palette is used for the graph. Three colors were requested from that palette but specifying any number larger than three would have worked and created a slightly different palette. Experimentation is needed to find the most suitable palette for any given graph. (Note: More information can be found in the [About Colors] section in the appendix.)

```{r 070.03}
# Simple Bar Plot
barplot(height = table(mtcars$gear),
  main = "Number of Cars By Gears",
  xlab = "Gears",
  ylab = "Count",
  col = cm.colors(3)
)

```

<div class="grsnote">The DataCamp interface generates graphics in a _Plots_ tab but because of the size of the interface those plots are "squished" and impossible to read. Click the double-headed arrow button on the _Plots_ tab to open the graph in a larger window for evaluation and copying to a document. If the graphic does not open in a larger window then temporarily pause the browser's pop-up blocker.</div>

### Guided Practice: Bar Plot

Using the [stackloss] data frame, create a bar plot for _Water.Temp_. The plot should meet these specifications: 

* Title: Water Temperature
* X-Axis label: Number
* Y-Axis label: Temperature
* Color: nine colors from the _cm.colors_ palette

```{r 070.04, ex="sc070.01", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.05, ex="sc070.01", type="sample-code"}
# Create a bar plot for Water.Temp using the specifications listed above.


```

```{r 070.06, ex="sc070.01", type="solution"}

barplot(height = table(stackloss$Water.Temp),
  main = "Water Temperature",
  xlab = "Number",
  ylab = "Temperature",
  col = cm.colors(9)
)

```

```{r 070.07, ex="sc070.01", type="sct"}

ex11neq <- "Check the plot specifications."
ex12neq <- "The main title should be Water Temperature."
ex13neq <- "The x-axis label should be Number."
ex14neq <- "The y-axis label should be Temperature."
ex15neq <- "The color palette should be specified as cm.colors(9)."

state11 <- ex() %>% check_function("barplot")

state11 %>% 
  check_arg("main") %>% 
  check_equal(incorrect_msg = ex12neq)

state11 %>% 
  check_arg("xlab") %>% 
  check_equal(incorrect_msg = ex13neq)

state11 %>% 
  check_arg("ylab") %>% 
  check_equal(incorrect_msg = ex14neq)

state11 %>% 
  check_arg("col") %>% 
  check_equal(incorrect_msg = ex15neq)

state11 %>% 
  check_result() %>% 
  check_equal(incorrect_msg = ex11neq)

success_msg("Perfect! A bar plot like this makes frequency analysis easier.")

```

### Deliverable: Bar Plot

Using the [cafe] data frame, create a bar plot for _meal_.  The plot should meet these specifications:

1. Title: Bar Plot
2. X-axis label: Meal
3. Y-axis label: Count
4. Color: four colors from the _topo.colors_ palette

Copy/paste the bar chart in the deliverable document for this lab.

```{r 070.08, ex="act070.01", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.09, ex="act070.01", type="sample-code"}
# Using the cafe data frame, create a bar plot for meal that matches the listed specifications.



```

-----

## Clustered Bar Plot

A clustered bar plot (sometimes called a "Grouped Bar plot") displays two or more categorical variables. In general, clustered bar plots are best at showing relationships between variables but not so good for determining the absolute size of each variable. The following plot shows the number of passengers on board the [Titanic] when it sank. While it is easy to determine that there were a lot more males than females on board, it is not possible to read the exact bar height of, for example, third class males.

```{r 070.10, fig.width=5.5,fig.height=4,fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

barplot(height = margin.table(Titanic,c(1,2)),
        beside = TRUE,
        main = "Titanic Passengers by Class and Sex",
        xlab = "Sex",
        ylab = "Count of Passengers",
        col = cm.colors(4)
        )
legend(x = "topright",
       y = c("First","Second","Third","Crew"),
       title = "Class",
       title.col = "navy",
       fill = cm.colors(4)
      )

```

### Demonstration: Clustered Bar Plot

The following script creates a clustered bar plot.

* Line 3: The first line of the script creates a custom color palette named _colpal_ (for “color palette”), which, contains color codes. In this case, the _colorRampPalette_ function will create the codes for color gradients between blue and white. More information about colors can be found in the [About Colors] section in the appendix.
* Line 5: This begins the `barplot` function. It creates a table that contains the counts for _cyl_ and _gear_ in the [mtcars] data frame and then uses that table to produce the bar plot. Note the order of the variables in the table command. The grouping variable is listed second. In this example, the cars are grouped by gears and within each group the number of cylinders are displayed. The height of each bar is determined by the count of cars in each group.
* Lines 6-8: These lines are essentially the same as for a simple bar plot as described above.
* Line 9: Setting legend to TRUE displays a legend in the corner of the plot. Whenever more than one variable is being plotted it is important to display a legend for the reader. In this case, the legend displays the colors used for the _cyl_ variable.
* Line 10: A stacked bar is the default type of plot but Line 8 instructs _R_ to create a plot with the variables beside each other. "Stacked" plots are described in the next section of this tutorial.
* Line 11: This rather odd-looking line adds a title to the legend, otherwise users would be confused about what the various colors used in the plot mean.
* Line 12: This selects three colors from the _colpal_ variable created in Line 3.

```{r 070.11}

# Clustered Bar Plot With Gradient Colors
colpal <- colorRampPalette(c("blue", "white"))

barplot(height = table(mtcars$cyl, mtcars$gear),
  main = "Cars by Gears and Cylinders",
  xlab = "Gears",
  ylab = "Count",
  legend = TRUE,
  beside = TRUE,
  args.legend = list(title = "Cylinders"),
  col = colpal(3)
)

```


### Guided Practice: Clustered Bar Plot

Using the [infert] data frame, create a clustered bar plot for _spontaneous_ grouped by _education_. The plot should meet these specifications: 

* Title: Spontaneous Cases by Education Level
* X-Axis label: Education Level
* Y-Axis label: Count
* Color: three values from a custom palette using orange to white
* Legend title: Spontaneous

```{r 070.12, ex="sc070.02", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.13, ex="sc070.02", type="sample-code"}
# Create a clustered bar plot for infert using the specifications listed above.


```

```{r 070.14, ex="sc070.02", type="solution"}

colpal <- colorRampPalette(c("orange", "white"))

barplot(height = table(infert$spontaneous, infert$education),
  main = "Spontaneous Cases by Education Level",
  xlab = "Education Level",
  ylab = "Count",
  col = colpal(3),
  legend = TRUE,
  beside = TRUE,
  args.legend = list(title = "Spontaneous")
)

```

```{r 070.15, ex="sc070.02", type="sct"}

ex21neq <- "The color specifications should be orange, white."
ex22neq <- "The height should be a table of spontaneous and education."
ex23neq <- "The main title should be Spontaneous Cases by Education Level."
ex24neq <- "The x-axis label should be Education Level."
ex25neq <- "The y-axis label should be Count."
ex26neq <- "The color palette should be specified as colpal(3)."
ex27neq <- "The legend value should be TRUE."
ex28neq <- "The beside value should be TRUE."
ex29neq <- "args.legend should have a title of Spontaneous."


state21 <- ex() %>% check_function("colorRampPalette")

state21 %>% 
  check_arg("colors") %>% 
  check_equal(incorrect_msg = ex21neq)

state22 <- ex() %>% check_function("barplot")

state22 %>% 
  check_arg("height") %>% 
  check_equal(incorrect_msg = ex22neq)

state22 %>%
  check_arg("main") %>%
  check_equal(incorrect_msg = ex23neq)

state22 %>% 
  check_arg("xlab") %>% 
  check_equal(incorrect_msg = ex24neq)

state22 %>% 
  check_arg("ylab") %>% 
  check_equal(incorrect_msg = ex25neq)

state22 %>% 
  check_arg("col") %>% 
  check_equal(incorrect_msg = ex26neq)

state22 %>% 
  check_arg("beside") %>% 
  check_equal(incorrect_msg = ex28neq)

state22 %>% 
  check_arg("args.legend") %>% 
  check_equal(incorrect_msg = ex29neq)

success_msg("Perfect! A clustered bar plot is useful for comparing variables.")

```


### Deliverable: Clustered Bar Plot

Using the [cafe] data frame, create a clustered bar plot that shows the number of people who ate a given _meal_ by _sex_. The plot should have three clusters (male, female, other) and each of those three clusters should have four meals (breakfast, lunch, dinner, other). The plot should meet these specifications: 

* Title: Clustered Bar Plot
* X-axis label: Sex
* Y-axis label: Count
* Color: four values from a custom palette using dark green to white
* Legend title: Meal

Copy/paste the bar chart in the deliverable document for this lab.

```{r 070.16, ex="act070.02", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.17, ex="act070.02", type="sample-code"}
# Using the cafe data frame, create a clustered bar chart that shows the number of people who ate a given meal by sex that matches the listed specifications.



```


-----

## Stacked Bar Plot

A stacked bar plot has one variable stacked on top of another. In general, these are very difficult to read and should only be used to make broad generalizations. Consider, for example, the following figure. This plot shows admissions for the University of California at Berkeley for six different programs. The top part of each bar (in brown) are the number admitted while the bottom part of each bar (in green) are the number rejected. Look at programs C and D. Were more students accepted in C or in D? Because these two values do not have the same baseline it is impossible to tell for certain which is larger.

```{r 070.18, fig.width=3,fig.height=3,fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

barplot(height = margin.table(UCBAdmissions,c(1,3)),
        main = "Berkeley Admissions",
        xlab = "Program ID",
        ylab = "Count of Admissions",
        col = terrain.colors(3)
        )

```

### Demonstration: Stacked Bar Plot

The following script is the same `barplot` function used in the clustered bar plots above, except _beside = TRUE_ is missing. By default, bar plots are stacked in _R_ so if the “beside” argument is missing (or set to “FALSE”) then the result will be a stacked bar plot.

```{r 070.19}
# Stacked Bar Plot With Gradient Colors
colpal <- colorRampPalette(c("Brown", "white"))

barplot(height = table(mtcars$cyl, mtcars$gear),
  main = "Number of Cars by Gears and Cylinders",
  xlab = "Gears",
  ylab = "Count",
  col = colpal(3),
  legend = TRUE,
  args.legend = list(title = "Cylinders")
)

```

It should be evident that the bar plot created in the above script is not very useful. While it is fairly easy to see that the number of 8-cylinder cars with three gears is much larger than the other categories, it is difficult to determine, for example, how many cars have five gears and eight cylinders. This difficulty is even worse when there are more than three levels for either of the two variables being plotted.

### Guided Practice: Stacked Bar Plot

Using the [infert] data frame, create a stacked bar plot for _induced_ grouped by _education_. The plot should meet these specifications: 

* Title: Induced Cases by Education Level
* X-Axis label: Education Level
* Y-Axis label: Count
* Color: three values from a custom palette using purple to white
* Legend title: Induced

```{r 070.20, ex="sc070.03", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.21, ex="sc070.03", type="sample-code"}
# Create a stacked bar plot for infert using the specifications listed above.


```

```{r 070.22, ex="sc070.03", type="solution"}

colpal <- colorRampPalette(c("purple", "white"))

barplot(height = table(infert$induced, infert$education),
  main = "Induced Cases by Education Level",
  xlab = "Education Level",
  ylab = "Count",
  col = colpal(3),
  legend = TRUE,
  args.legend = list(title = "Induced")
)

```

```{r 070.23, ex="sc070.03", type="sct"}

ex31neq <- "The color specifications should be purple, white."
ex32neq <- "The height should be a table of induced and education."
ex33neq <- "The main title should be Induced Cases by Education Level."
ex34neq <- "The x-axis label should be Education Level."
ex35neq <- "The y-axis label should be Count."
ex36neq <- "The color palette should be specified as colpal(3)."
ex37neq <- "The legend value should be TRUE."
ex38neq <- "args.legend should have a title of Induced."


state31 <- ex() %>% check_function("colorRampPalette")

state31 %>% 
  check_arg("colors") %>% 
  check_equal(incorrect_msg = ex31neq)

state32 <- ex() %>% check_function("barplot")

state32 %>% 
  check_arg("height") %>% 
  check_equal(incorrect_msg = ex32neq)

state32 %>%
  check_arg("main") %>%
  check_equal(incorrect_msg = ex33neq)

state32 %>% 
  check_arg("xlab") %>% 
  check_equal(incorrect_msg = ex34neq)

state32 %>% 
  check_arg("ylab") %>% 
  check_equal(incorrect_msg = ex35neq)

state32 %>% 
  check_arg("col") %>% 
  check_equal(incorrect_msg = ex36neq)

# This check doesn't work. TestThis seems to want to check legend as a function not an arg.
# fun32state %>% 
#   check_arg("legend") %>% 
#   check_equal(incorrect_msg = ex37neq)

state32 %>% 
  check_arg("args.legend") %>% 
  check_equal(incorrect_msg = ex38neq)

success_msg("Good Job! A stacked bar plot is useful for comparing variables.")

```

### Deliverable: Stacked Bar Plot

Using the [cafe] data frame, create a stacked bar chart that shows the number of people who ate a given _meal_ by _sex_. The chart should have three columns (male, female, other) and each of those three columns should have four meals (breakfast, lunch, dinner, other). The chart should meet these specifications:

* Title: Stacked Bar Plot
* X-axis label: Sex
* Y-axis label: Count
* Color: four values from a custom palette using goldenrod to white
* Legend title: Meal

Copy/paste the bar chart in the deliverable document for this lab.

```{r 070.24, ex="act070.03", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.25, ex="act070.03", type="sample-code"}
# Using the cafe data frame, create a stacked bar plot that shows the number of people who ate a given meal by sex that matches the listed specifications.

```


-----

## Pie Chart

A pie chart is commonly used to display categorical data; however, pie charts are notoriously difficult to interpret, especially if the writer uses some sort of 3-D effect or “exploded” slices. The human brain seems able to easily compare the heights of two or more bars, as in bar plots, but the areas of two or more slices of a pie chart are difficult to compare. For this reason, pie charts should be avoided in research reports. If they are used at all, they should only illustrate one slice's relationship to the whole, not comparing one slice to another; and no more than four or five slices should ever be presented on one chart.

The following figure shows the results of an experiment reported in the [chickwts] data frame to compare the effectiveness of various feed supplements on the growth rate of chickens. This figure illustrates the problem with pie charts. Notice that "casein" seems to promote growth better than "horsebean," but it is impossible to determine if "casein" is better than "sunflower" from this chart.

```{r 070.26, fig.width=4,fig.height=4,fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

count <- aggregate(chickwts$weight, by=list(chickwts$feed), FUN=mean)
labels <- c(levels(chickwts$feed))
pie(count$x,
    labels = labels,
    main = "Chick Weights by Type of Feed",
    col = terrain.colors(6)
    )

```

### Demonstration: Pie Chart

The following script creates a pie chart.

* Line 2: This starts a pie chart function. The "x" parameter is the data that needs to be charted. In this line, the _feed_ variable in the [chickwts] data frame is extracted to a table since the pie chart function expects input in the form of a table.
* Lines 3-4: These lines define the main title and colors used for the pie chart. These parameters are the same as was seen in other graphs in this lab.
* Line 5: This tells _R_ to use the labels used in the _feed_ variable as the labels on the pie chart.

```{r 070.27}
# Count of Chicks by Feed
pie(x = table(chickwts$feed),
  main = "Count of Chicks by Feed",
  col = rainbow(6),
  labels = c(levels(chickwts$feed))
  )

```

Note: The pie chart shows the number of chicks that were given a particular type of feed. Even though the pie “slices” are very nearly the same size there was a slightly different number of chicks on each type of feed.

### Guided Practice: Pie Chart

Create a pie chart for the [state.division] data frame. NOTE: This data frame has only one vector so it is not necessary to use the `$` operator. The chart should meet these specifications: 

* Title: States by Division
* Color: nine colors from the _topo.colors_ palette
* Labels: for each pie slice

```{r 070.28, ex="sc070.04", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.29, ex="sc070.04", type="sample-code"}
# Create a pie chart for state.division using the specifications listed above.


```

```{r 070.30, ex="sc070.04", type="solution"}

pie(x = table(state.division),
  main = "States by Division",
  col = topo.colors(9),
  labels = c(levels(state.division))
  )

```

```{r 070.31, ex="sc070.04", type="sct"}

ex41neq <- "The chart should use a table of state.division for input."
ex42neq <- "The main title should be States by Division."
ex43neq <- "The color palette should be topo.colors(9)."
ex44neq <- "The labels should be the levels of state.division."

state41 <- ex() %>% check_function("pie")

state41 %>% 
  check_arg("x") %>% 
  check_equal(incorrect_msg = ex41neq)

state41 %>%
  check_arg("main") %>%
  check_equal(incorrect_msg = ex42neq)

state41 %>% 
  check_arg("col") %>% 
  check_equal(incorrect_msg = ex43neq)

state41 %>% 
  check_arg("labels") %>% 
  check_equal(incorrect_msg = ex44neq)

success_msg("Perfect! Pie charts are very popular.")

```

### Deliverable: Pie Chart

Using the [cafe] data frame, create a pie chart that shows the number of people who ate a given _meal_ (breakfast, lunch, dinner, other). The chart should meet these specifications:

* Title: Pie Chart
* Colors: six colors from the _terrain_ color palette
* Labels: for each pie slice

Copy/paste the pie chart in the deliverable document for this lab.

```{r 070.32, ex="act070.04", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.33, ex="act070.04", type="sample-code"}
# Using the cafe data frame, create a pie chart that shows the number of people who ate a given meal  that matches the listed specifications.



```

-----

## Heat Map

Heat maps use colors to depict the counts of variables and are commonly found around election time to depict how precincts are voting, red for republican and blue for democrat. They are also routinely used on weather maps to depict areas with the greatest probability for rain or snow. While heat maps can be displayed in a geographical format where, for example, the various states are shaded to represent some factor, they are also commonly seen as a grid. The following figure shows a heat map was taken from the [swiss] data frame and shows various socioeconomic indicators by province in Switzerland from 1888.

```{r 070.34,fig.width=4,fig.height=4,fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

x <- as.matrix(swiss[1:15,])
heatmap(x,
        Rowv=NA,
        Colv=NA,
        scale="column",
        margins=c(10,7),
        main = "Swiss Stats",
        ylab = "Province",
        xlab = "Indicator" 
        )

```

In a heat map produced by _R_, lighter colors represent larger numbers. Thus, the province with the highest fertility rate is _Franches-Mnt_ since it has the lightest color and the province with the least agriculture is _Courtelary_ since it has the darkest color for those variables. Interpreting the heat map can be a challenge for the researcher. In some cases a light color would be positive and in others negative. For example, the highest education level would be in _Neuveville_ (positive) but the highest infant mortality would be in _Porrentruy_ (negative). Also, the colors are often very similar and difficult to distinguish. For example, for _examination_, _Cossonay_ has a numeric value of 22 while _Aigle_ has 21. These two colors are slightly different but it would be difficult to detect that from the image. Often, the best that can be done with a heat map is identifying broad generalizations.

### Demonstration: Heat Map

The following script creates a heat map for _Party Size_ by _Meal_ in the [cafe] data frame.

* Line 4: This line creates a contingency table from columns 8 and 4 of the [cafe] data frame and store that table in a variable named _htbl_. Those two columns contain the data requested for this heatmap, column 8 is the party size and column 4 is the meal.
* Line 5: _R_ can store data in several different formats and many, like vector and data frame, are used by other labs in this manual. Heat maps require data to be in a matrix format and this line converts the *htbl* contingency table into a matrix named *hmap*.
* Line 6: This is the start of the heat map function. This line instructs _R_ to create a heat map from the _hmap_ matrix created in Line 5.
* Line 7: The main title of the heatmap is _Cafe Ptysize by Meal_.
* Line 8: The x-axis is labeled _Meal_.
* Line 9: The y-axis is labeled _Ptysize_.
* Line 10: This suppresses the row _dendogram_ that is used to order the rows. The best way to see what this line does is to comment it out and re-run the script.
* Line 11: This suppresses the column _dendogram_.
* Line 12: Sets the heat map to scale the columns. In this way, the color for each column cell is calculated such that the entire column’s mean is zero and the standard deviation is one. The other option is to scale “row” and researchers would want to try both to see which provides a better heat map.
* Line 13: This sets the right and bottom margins. The values were found by simple trial-and-error to produce the most legible heat map.

```{r 070.35, ex="heatmap", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```


```{r 070.36, ex="heatmap", type="sample-code"}

# Cafe Party Size by Meal
htbl <- table(cafe[,c(8,4)])
hmap <- as.matrix(htbl)
heatmap(hmap,
  main = "Cafe Ptysize by Meal",
  xlab = "Meal",
  ylab = "Ptysize",
  Rowv=NA,
  Colv=NA,
  scale="column",
  margins=c(8,3)
)

```

The following script creates a heat map for the [USJudgeRating] data frame.

* Line 1: _R_ can store data in several different formats and many, like vector and data frame, are used by other tutorials in this series. Heat maps require data to be in a matrix format and this line converts the first 20 lines, out of 43, in the data frame into a matrix named _hmap_. Notice how the first twenty lines in that data frame are specified, using _[20:1,]_ which also reverses their order so they are alphabetized. Finally, _x_ is the name of the parameter in the `as.matrix` function that receives the input data.
* Line 2: This is the start of the heat map function. This line instructs _R_ to create a heat map from the _hmap_ matrix. _R_ designates the input variable for _heatmap_ to be _x_.
* Line 3: The main title of the heatmap is _US Judge Ratings_.
* Line 4: The x-axis is labeled _Characteristic_.
* Line 5: This suppresses the row _dendogram_ that is used to order the rows. The best way to see what this line does is to comment it out and re-run the script.
* Line 6: This suppresses the column “dendogram.”
* Line 7: Sets the heat map to scale the rows. In this way, the color for each row cell is calculated such that the entire row’s mean is zero and the standard deviation is one. The other option is to scale “column” and researchers would want to try both to see which provides a better heat map.
* Line 8: This sets the right and bottom margins. The values were found by simple trial-and-error to produce the most legible heat map.

Note that colors were not specified for this heat map. While a special color palette could be used, the default colors used by _R_ work well.

```{r 070.37}
hmap <- as.matrix(x = USJudgeRatings[20:1,])
heatmap(x = hmap,
  main = "US Judge Ratings",
  xlab = "Characteristic",
  Rowv=NA,
  Colv=NA,
  scale="row",
  margins=c(8,3)
)

```

### Guided Practice: Heat Map

Create a heat map for the [attitude] data frame. The heat map should meet these specifications: 

* Scope: Only the first 20 lines from the data frame should be used, like _attitude[1:20,]_
* Title: Clerical Employees Attitude
* X-axis label: Characteristic
* Y-axis label: Department 
* Rowv/Colv symbols: NA
* Scale: row
* Margins: _c(8,3)_

```{r 070.38, ex="sc070.05", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.39, ex="sc070.05", type="sample-code"}
# Create a heat map for attitude using the specifications listed above.


```

```{r 070.40, ex="sc070.05", type="solution"}

hmap <- as.matrix(x = attitude[1:20,])

heatmap(x = hmap,
  main = "Clerical Employees Attitude",
  xlab = "Characteristic",
  ylab = "Department",
  Rowv=NA,
  Colv=NA,
  scale="row",
  margins=c(8,3)
)

```

```{r 070.41, ex="sc070.05", type="sct"}

ex51neq <- "Check to be sure the x value is attitude[1:20,] -- don't forget the comma after 20!"
ex52neq <- "The x value should be hmap."
ex53neq <- "The main title should be Clerical Employees Attitude."
ex54neq <- "The x-axis label should be Characteristic."
ex55neq <- "The y-axis label should be Department."
ex56neq <- "Rowv should be NA."
ex57neq <- "Colv should be NA."
ex58neq <- "Scale should be row."
ex59neq <- "The margins should be set for 8, 3."

ex() %>% 
  check_object("hmap") %>%
  check_equal(incorrect_msg = ex51neq)

state51 <- ex() %>% 
  check_function("heatmap")

state51 %>% 
  check_arg("x") %>% 
  check_equal(incorrect_msg = ex52neq)

state51 %>%
  check_arg("main") %>%
  check_equal(incorrect_msg = ex53neq)

state51 %>% 
  check_arg("xlab") %>% 
  check_equal(incorrect_msg = ex54neq)

state51 %>% 
  check_arg("ylab") %>% 
  check_equal(incorrect_msg = ex55neq)

state51 %>% 
  check_arg("Rowv") %>% 
  check_equal(incorrect_msg = ex56neq)

state51 %>%
  check_arg("Colv") %>%
  check_equal(incorrect_msg = ex57neq)

state51 %>% 
  check_arg("scale") %>% 
  check_equal(incorrect_msg = ex58neq)

state51 %>% 
  check_arg("margins") %>% 
  check_equal(incorrect_msg = ex59neq)

success_msg("Good Job! Heat maps display a lot of data in a compact way.")

```

### Deliverable: Heat Map

Using the [cafe] dataset, create a heat map that compares the number of people dining at each _meal_ (breakfast, lunch, dinner, other) for each _day_ (Monday, Tuesday, etc.). The goal is to find the most/least popular meal for each day of the week. (Tip: _day_ is column 3 and _meal_ is column 4 in the data frame.) The chart should meet these specifications:

* Scope: This data frame is small so do not restrict the number of lines used, but specify the columns needed like _cafe[,c(3,4)]_
* Title: Heat Map
* X-axis label: Meal
* Y-axis label: Day
* Rowv/Colv symbols: NA
* Scale: column
* Margins: _c(8,7)_

Copy/paste the heat map in the deliverable document for this lab.

```{r 070.42, ex="act070.05", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.43, ex="act070.05", type="sample-code"}
# Using the cafe dataset, create a heat map that compares the number of people dining at each meal for each day that matches the listed specifications.



```

-----

## Mosiac Plot

A mosiac plot indicates the relative counts of items in a data frame by sizing areas on a grid. The following figure is a mosiac plot that indicates the relationship between the number of gears and cylinders in several cars in the [mtcars] data frame. Notice that 8-cylinder cars overwhelmingly have three gears while 4-cylinder cars tend to have four gears. This plot gives a quick visual representation of the relationships between categorical variables, just as a pie chart shows the relationship between continuous variables. A mosiac plot would suffer the same weaknesses as a pie chart and are, generally, rather difficult to interpret.

```{r 070.44, fig.width=3.5,fig.height=4,fig.align="center", echo=FALSE, message=FALSE, warnings=FALSE, tut=FALSE}

plot(table(mtcars$cyl,mtcars$gear),
     main = "US Car Information",
     xlab = "Cylinders",
     ylab = "Gears",
     col = terrain.colors(3)
     )

```

### Demonstration: Mosaic Plot

The following script creates a mosiac plot.

* Line 2: A mosiac plot requires the input to be in table format so this line creates a table from the _gear_ and _cyl_ variables in the [mtcars] data frame. The data specification is entered as variable _x_ in a plot.
* Lines 3-6: These are similar to those used for other graphics functions and should be fairly easy to understand.

```{r 070.45}
# Mosiac Plots Using MTCars
plot(x = table(mtcars$gear, mtcars$cyl),
  main = "Gears vs Cylinders",
  xlab = "Gears",
  ylab = "Cylinders",
  col = topo.colors(3)
  )

```

### Guided Practice: Mosaic Plot

Create a mosaic plot for the induced and education vectors in the [infert] data frame. The plot should meet these specifications:

* Title: Compare Induced and Education
* X-axis label: Number Induced
* Y-axis label: Education Level
* Color: five colors from the _terrain.colors_ palette

```{r 070.46, ex="sc070.06", type="pre-exercise-code"}

# No pre-exercise code for this exercise

```

```{r 070.47, ex="sc070.06", type="sample-code"}
# Create a mosaic plot for infert using the specifications listed above.

```

```{r 070.48, ex="sc070.06", type="solution"}

plot(x = table(infert$induced, infert$education),
  main = "Compare Induced and Education",
  xlab = "Number Induced",
  ylab = "Education Level",
  col = terrain.colors(5)
  )

```

```{r 070.49, ex="sc070.06", type="sct"}

ex61neq <- "Check to be sure the x value is a table of induced and education."
ex62neq <- "The main title should be Compare Induced and Education."
ex63neq <- "The x-axis label should be Number Induced."
ex64neq <- "The y-axis label should be Education Level."
ex65neq <- "The color should be terrain.colors(5)."

state61 <- ex() %>% 
  check_function("plot")

state61 %>% 
  check_arg("x") %>% 
  check_equal(incorrect_msg = ex61neq)

state61 %>%
  check_arg("main") %>%
  check_equal(incorrect_msg = ex62neq)

state61 %>% 
  check_arg("xlab") %>%
  check_equal(incorrect_msg = ex63neq)

state61 %>% 
  check_arg("ylab") %>%
  check_equal(incorrect_msg = ex64neq)

state61 %>% 
  check_arg("col") %>%
  check_equal(incorrect_msg = ex65neq)

success_msg("Perfect! Mosaic plots are not too common but may be useful in some situations.")

```

### Deliverable: Mosaic Plot

Using the [cafe] dataset, create a mosaic plot that compares the number of people dining at each _meal_ (breakfast, lunch, dinner, other) to the rating for service (_svc_). The plot should meet these specifications:

* Title: Mosaic Plot
* X-axis label: Meal
* Y-axis label: Service
* Color: five colors from the _terrain.colors_ palette

Copy/paste the mosaic plot in the deliverable document for this lab.

```{r 070.50, ex="act070.06", type="pre-exercise-code"}

cafe <- read.csv('https://labs.basv316.com/cafe.csv')

```

```{r 070.51, ex="act070.06", type="sample-code"}
# Using the cafe dataset, create a mosaic plot that compares the number of people dining at each meal to the rating for service that matches the listed specifications.



```

-----

## Deliverable

Complete the activities in this lab and consolidate the responses into a single document. Name the document with your name and "Lab 6," like "George Self Lab 6" and submit that document for grade.
